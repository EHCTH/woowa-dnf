## 작업 시간 기록 
### 12~15일 작업 시간 기록 누락
> 대신 2주차 회고에서 해당 기간의 작업 내용을 정리했습니다.

<img src="image/2025-11-2%7E7.png" alt="2025-11-2~7 작업 시간" width="300" />

<img src="image/2025-11-8%7E11.png" alt="2025-11-8~11 작업 시간" width="300" />

<img src="image/2025-11-16%7E23.png" alt="2025-11-16~23 작업 시간" width="300" />

## 1주차 회고 (4 ~ 11) // 외부 API 도메인 지옥
1주차 첫날, 오픈 미션 설명회를 듣기 위해 줌에 들어갔다.  
처음에는 오픈 미션이 이전 4주차 미션들과는 다르게 진행된다고 해서  
txt 파일로 공통 tsv/csv 데이터를 주고 그걸 바탕으로 원하는 미션을 구현하는 방식일 거라고 예상했다.

하지만 그 예상은 완전히 빗나갔다.  
오픈 미션은 나에게 청천벽력 같은 이야기였다.  
"실제로 사용할 수 있는 간단한 서비스를 직접 개발해 보라"는 요구였기 때문이다.

이 말을 듣고 나서 한편으로는 두려웠지만,  
다른 한편으로는 지원서에 적어 두었던 "던전앤파이터 웹 서비스"를 제대로 만들어 볼 기회라고 느꼈다.

우테코를 시작하기 전에 한 번 맛보기로 로컬에서 돌아가는 서비스를 만들어 보려고 시도한 적이 있다.   
그런데 우테코에서도 같은 프로젝트를 다시 하게 되었다.  
하지만 이미 한 번 해봤다는 이점보다는 단점이 더 크게 느껴졌다.

게임이라는 특성상 어떤 캐릭터는 특정 아이템을 착용하고 있고,
어떤 캐릭터는 같은 슬롯에 아무것도 착용하지 않은 경우가 많다.  
그래서 `External DTO → 도메인 객체 변환` 구간이 말 그대로 "지옥" 같았다.

어떤 캐릭터는 계속 `null`이 나오고, 어떤 캐릭터는 정상으로 나와서  
이 `null`들을 처리하는 데만 거의 일주일은 쓴 것 같다.

처음에는 `@JsonSetter`를 사용해서 `null`을 방지하려고 했다.  
하지만 필드마다 `@JsonSetter`를 다는 방식은 점점 애너테이션이 남발된다는 느낌이 들었고,  
“이걸 전부 이렇게 관리해도 되는 걸까?”라는 고민이 생겼다.

그래서 한 번은 `JacksonConfig`를 만들어 전역 설정으로 해결해 보려고 했다.  
전역 설정과 필드별 `@JsonSetter`를 비교해 보니,  
전역 설정만 사용했을 때는 `null`이 10~20개 정도 나왔지만  
필드별로 직접 `@JsonSetter`를 달았을 때는 `null`이 1개 정도로 줄어들었다.

결국, 정확한 도메인 값을 위해서는 필요한 필드에 직접 `@JsonSetter`를 다는 방식으로 정리하게 되었다.
그렇게 `External DTO -> 도메인 -> ViewDTO` 로 방식으로 구현하게 되었다

## 2주차 회고(12 ~ 18) // 리팩토링, DB 연결, AOP
2주차에는 1주차에 만들어 놓았던 코드들을 다시 바라보는 시간이었다.    
처음에는 `Character`라는 애그리거트 루트를 설정하지 않고, 일단 모든 도메인이 잘 작동하는지 에그리거트 별로 나누어서
`HTML`을 작성했다. 그러다가 어느 정도 잘 작동하는 것 같아 `Character`라는 애그리거트 루트 를 설정하게 되었다.

`Character`를 중심으로 장비, 아바타, 버프, 크리쳐, 휘장을 모아서 하나의 도메인처럼 보이게 만들고  
조회용 퍼사드(`CharacterSearchFacade`)와 저장 퍼사드(`CharacterRefreshFacade`)를 이용하여  
외부 API 응답은 어셈블러를 통해 도메인으로 변환한 뒤 그 도메인을 `ViewDto`로 사용하게끔 정리했다.  

처음에는 메모리에서만 작동하도록 `Map`을 사용하여 로컬에서만 돌아가도록 했다.  
리팩토링이 어느 정도 정리되자, 이번에는 "DB에 실제로 캐릭터를 저장해 보고 싶다"는 생각이 들었다.  
(물론 안 해 본 걸 해보자는 취지가 크긴 했다)   

지금까지는 모든 데이터를 메모리에서만 다루고 있었지만 
“이번 기회가 아니면 언제 새로운 걸 시도해 볼까”라는 마음 때문에 
로컬 MySQL을 붙이고, JPA 엔티티와 도메인 사이를 어떻게 연결할지 고민하기 시작했다.

이때 메모리 기반 구현에서 JPA를 사용하는 구조로 넘어가면서 “이래서 JPA를 쓰는구나”를 제대로 느낀 것 같다.  
메모리 리포지토리에서 `findXxx()`를 왜 사용하는지도 이때 비로소 이해하게 되었다.

이때 "도메인을 그대로 저장"할지 "스냅샷 형태로 저장"할지도 많이 고민했다.   
결국 “스테이터스가 변할 때 그 순간의 상태를 남기기 위해” 
도메인 개념을 최대한 유지한 채로 스냅샷 형태로 저장하는 방향으로 생각을 굳혀 갔다.    
또, `application-*.properties`와 프로필(`memory`, `mysql`)을 어떻게 나눌지  
DB 접속 정보 API키 같은 민감한 정보들을 Git에 올리지 않으려면 어떻게 관리해야 하는지도 함께 고민했다.  

2주차가 거의 지나고 나니  서비스가 “그냥 외부 API를 호출해서 보여주는 휘발성 메모리 페이지”에서   
조금씩 "도메인과 DB를 가진 진짜 서비스"에 가까워지고 있다는 느낌을 받았다.    
아직은 로컬에서만 작동하고 있었지만 데이터가 실제로 저장된다는 사실만으로도 꽤 뿌듯했다.  

그리고 김영한 님 강의에서 본 AOP도 한 번 적용해 보았다.
그 전에는 각 로직마다 로그를 직접 찍어야 했는데 
공통 관심사를 분리해서 AOP로 묶어 두니 로그 관리가 확연히 달라졌다는 걸 체감했다.  
특히 강의에서 처음에는 s(초) 단위로 로그를 남겼다가 
갑자기 ms(밀리초) 단위로 바꾸라는 요구사항이 내려왔던 예시가 인상 깊었는데 
그 스토리가 떠올라 이번 기회에 나도 AOP를 도입해 보게 되었다.  

물론 아직 갈 길은 멀지만, 2주차에 했던 DB 연결 준비는 
앞으로 새로운 기능이나 기술을 접할 때 느끼던 두려움이  
조금은 사그라지는 계기가 되었다.  

## 3주차 회고(19 ~ 23) // CI/CD · Docker · EC2 · Nginx, WebSocket 한 번도 접해보지 않았던 스택 사용
3주차는 말 그대로 “두려움과 신세계” 같은 시간이었다.  
CI/CD, Docker, EC2, Nginx 같은 키워드는 들어만 봤지 
직접 만져본 건 이번이 처음이라 시작부터 두려움이 컸다.  

일단 이 과정에서 GPT랑 구글링을 정말 많이 활용했다.  
그만큼 실수도 많이 했고, 시행착오도 많았다.  

처음으로 AWS 계정 생성부터 시작했다  "AWS 루트 사용자", "IAM 사용자"처럼 처음 들어보는 단어들만 나와서
계정을 만드는 것 자체도 꽤 막막했다.  
그래도 하나씩 찾아보면서 겨우겨우 AWS 계정을 만들었다.  

이제 EC2 인스턴스를 활용해서 서버를 열어보려고 했다.  
과금이 걱정돼서 일단 프리티어에 해당하는 t3.micro 인스턴스 유형을 선택했고 
SSH 접속을 위한 키 페어 설정까지 마무리했다.  

그 다음에는 애플리케이션 배포를 위해 도커를 설치했다.
이미 맥에 `Homebrew`가 설치되어 있어서 `brew`를 이용해 도커를 설치했다.  
도커 허브에서 액세스 토큰을 발급받고 레포지토리를 만든 뒤 
프로젝트 루트에서 도커 이미지를 빌드해서 푸시했다.  
여기까지는 비교적 수월하게 진행되었다.  

마지막으로 `CI/CD`를 위해 `GitHub Secrets`를 설정하고 `.github/workflows/cicd.yml` 파일을 작성해서 
코드를 푸시하면 자동으로 빌드/배포가 되도록 구성했다.  
로컬에서는 `CI/CD가` 잘 동작했다.  

그렇게 기본 설정을 마친 뒤 EC2에도 도커를 설치했다.  
문제는 `EC2`에 `MySQL`을 설치하면서부터였다.  
설정을 만지는 도중에 서버가 계속 다운되기 시작했다.  
`t3.micro` 인스턴스라 리소스가 부족해서 그런 것 같다는 생각이 들었고 
실제로도 그 추측이 맞았던 것 같았다.  

결국에는 인스턴스를 새로 만드는 쪽을 선택했고 이번에는 한 단계 올린 `t3.small`로 다시 서버를 시작하게 되었다.  
그리고 서버가 꺼졌다 켜지면 IP가 변경되는 문제 때문에 `엘라스틱 IP`도 도입했다.  

`application-mysql.properties`와 `.bash_profile`에 필요한 환경 변수를 입력했고,
그 후 도커 네트워크를 만들고 컨테이너를 실행했다.
이제 애플리케이션은 큰 문제 없이 잘 돌아가기 시작했지만, 나에게는 도커 컨테이너 실행 명령어가 너무 복잡하게 느껴졌다.  
그래서 구글링을 통해 하나하나씩 뜯어보며 공부했다.  

도커 컨테이너 실행 명령어는 대략 이렇게 이해했다.  

- `docker run`: 이미지를 기반으로 컨테이너를 생성하고 실행
  - `-d`: 백그라운드에서 컨테이너 실행
  - `--name`: 컨테이너 이름 설정
  - `--network`: 도커 네트워크 설정 (같은 네트워크에 있는 컨테이너끼리 통신)
  - `-p {호스트포트}:{컨테이너포트}`: 호스트 포트를 컨테이너 포트로 매핑
  - `-e`: 환경 변수 설정
  - `-v {호스트경로}:{컨테이너경로}`: 호스트 디렉터리/파일을 컨테이너에 마운트

여기에서 특히 `-p`, `-v` 같은 옵션이 너무 생소해서 많이 찾아보게 되었다.  
"마운트"라는 단어 자체도 처음 들어봐서 도커 공식 문서를 보고 구글링으로 여러 블로그를 참고한 다음 
내가 이해한 내용이 맞는지 `GPT`에게 계속 복기하면서 확인했다.  

드디어 서버를 열고 주소를 입력했을 때 원하던 사이트가 화면에 떴다.  
이때 기분은 말로 형용할 수 없을 만큼 행복했다.

하지만 로컬에서는 한글로 잘 나오던 화면이 EC2 서버로 접속하니 영어로만 보이는 문제가 생겼다.  
(`messages.properties`에 한국어/영어 버전을 따로 설정해둔 상태라 더 혼란스러웠다)    

“왜 이렇게 나오지?”라는 생각으로 원인을 추적하다 보니 
처음에 EC2 리전을 서울이 아닌 시드니로 생성해 두었다는 걸 알게 되었다.

그래서 인스턴스를 삭제하고 서울 리전으로 새로 생성해서 다시 환경을 구성했다.  
하지만 여전히 화면은 계속 영어로만 나왔다.  

브라우저 개발자 도구를 열어 `Locale` 값도 확인해 봤지만 한국으로 설정되어 있어서 
문제는 점점 더 미궁 속으로 빠져들었다.  

결국 시간 내에 원인을 끝까지 찾지 못해서 임시 방편으로 영어 메시지 파일을 삭제해 강제로 한글만 나오도록 처리했다.  

그 후에는 다시 도커 쪽을 정리했다.  
매번 길고 복잡한 `docker run` 명령을 치는 게 너무 비효율적으로 느껴져서
`EC2`에 배포 스크립트를 하나 만들어, 스크립트에서 도커 컨테이너 실행 명령어를 대신 호출하도록 했다.

그러다가 나중에서야 `docker compose`라는 것을 알게 되었다.  
도커 컴포스를 써보니 구성이 한눈에 들어온다는 점에서 가시성이 확 좋아졌다고 느꼈다.  
지금은 대략 아래와 같은 구조로 정리해서 사용하고 있다.  

```yml
services:
  mysql:
    image: mysql:8.0
    container_name: "${CONTAINER_NAME}"
    environment:
      MYSQL_ROOT_PASSWORD: "${MYSQL_ROOT_PASSWORD}"
      MYSQL_DATABASE: "${MYSQL_DATABASE}"
      MYSQL_USER: "${MYSQL_USER}"
      MYSQL_PASSWORD: "${MYSQL_PASSWORD}"
    networks:
      - "${NETWORK}"
    ports:
      - "${PORTS}"
    volumes:
      - "${VOLUMES}"

volumes:
  "${VOLUMES}"
```

그렇게 서버까지 배포한 뒤에는 `Route53`에서 도메인을 구입했다.  
도메인을 구입한 후 현재 서버에 연결해서, 이제는 도메인으로 접속할 수 있게 만들었다.  
처음에는 `woowa-dnf.xyz`로만 접근 가능했지만 
더 유연하게 하기 위해 `www.woowa-dnf.xyz`로도 접근할 수 있도록 확장했다.  

하지만 `HTTPS`를 적용하지 않아서 브라우저에서 “안전하지 않음” 표시가 나와
`Nginx`를 이용해 `HTTPS`도 적용했다.  

서버 쪽 환경을 어느 정도 정리하고 나서는 이번에는 채팅창 기능도 한 번 도입해보고 싶어서
`feat/chat` 브랜치를 새로 만들어 개발을 진행했다.  

브랜치를 새로 만든 이유는 깃헙에서 `merge`를 직접 경험해 보고 싶었기 때문이다.    
유튜브와 구글링으로 먼저 개념을 공부한 뒤 시도했다.  
이미 만든 `main` 브랜치에 악영향이 가면 안된다고 생각하였다.  
PR을 올리고 코드 리뷰를 하는 이유가 무엇인지도 이 과정을 통해 이해하게 되었다.    
다만 혼자 개발하는 상황이라, PR을 정식으로 올리기보다는 main 브랜치로 직접 merge 하는 쪽을 선택했다.    
코드를 조금만 수정해도 CI/CD가 매번 돌아가 시간이 꽤 걸려서
이후에는 CD는 빼고 브랜치 단위로 CI만 따로 설정해 볼 계획이다.    

채팅 서비스를 만드는 일 자체는 외부 API를 이용해 캐릭터 정보를 만드는 작업과 비교하면 상대적으로 덜 부담스럽게 느껴졌다.    
물론 아직 삭제 기능은 운영자 전용 API로만 막아둔 상태지만 추후에는 채팅방 입장 전에 비밀번호를 설정하고 
비밀번호가 맞는 사용자라면 스스로 자신의 메시지를 삭제할 수 있도록 기능을 확장할 계획이다.    

이렇게 다사다난한 3주차를 겪고 나니   
“내가 그동안 뭘 하고 있었지?”를 처음부터 다시 돌아보게 되었다.

나는 그동안 "개발 자체보다는 코드 스타일을 예쁘게 만드는 데 더 집착했던 건 아닐까" 라는 생각이 들었다.    

"이걸 어떻게 하면 스트림으로 더 간단하게 풀 수 있을까?"    
"여기를 더 함수형스럽게 바꿀 수 없을까?"    
"어떻게 하면 동적으로 관리 할까?"  

늘 이런 고민만 하느라 정작 진정한 개발의 본질인 “서비스를 만드는 일”은 뒤로 미뤄두고 있었던 것 같다.    

이번 오픈 미션을 통해 새로운 시야를 얻은 느낌이라 속 시원하다.    
코딩을 처음 시작했을 때처럼, 오랜만에 배움의 즐거움이라는 걸 다시 느꼈다.  
그리고 “나는 지금 무엇을 위해 개발을 하고 있는지”를 스스로에게 다시 질문하게 되었다.

길다면 길고, 짧다면 짧은 3주차라는 시간 동안 이렇게 많은 걸 배웠다는 사실이 놀랍다.  
그리고 이걸 왜 그동안 안해 봤으니 “무섭다”는 이유로 피하려고만 했을까 라는 생각도 들었다.  

“난 백엔드니까 프론트 못 해” 같은 마음가짐도 사라졌다.    
지금 시대가 어떤 시대인데, GPT도 있고 인터넷도 있고 유튜브도 있는데 못 할 이유가 없다는 생각이 들었다.    
그건 그냥 스스로를 지키기 위한 "회피용 핑계"였을 뿐이라는 걸 인정하게 됐다.

이번 프리코스 중에서, 마지막 주차가 가장 강하게 기억에 남을 것 같다.  

